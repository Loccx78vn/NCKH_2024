---
title: "MILP"
author: "Lộc"
date: "2023-12-18"
output: html_document
---

```{r}
#Call packages
pacman::p_load(rio,
               here,
               janitor,
               tidyverse,
               dplyr,
               magrittr,
               ggplot2,
               purrr,
               lubridate,
               mice,
               plotly)
```

##Case 1: Assignment problems:

![Assigning problem's model](/Users/locca/Downloads/Assigning.png)

```{r}
library(ompr)
n <- 40 #Have 40 students
m <- 4
capacity <- rep.int(11, m) # all have equal capacities

set.seed(1234)
preference_data <- lapply(seq_len(n), function(x) sample(seq_len(m), 3))
preferences <- function(student) preference_data[[student]]


# the weight of a student choosing a course
# if the course is not among the preferences, the weight is -100000
weight <- function(student, course) {
  p <- which(as.numeric(course) == preferences(as.numeric(student)))
  as.integer(if (length(p) == 0) {
    -100000
  } else {
    p
  })
}


library(ompr)
library(ompr.roi)
library(ROI.plugin.glpk)

model <- MIPModel() %>%
  # 1 iff student i is assigned to course m
  add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
  # maximize the preferences
  set_objective(sum_expr(weight(i, j) * x[i, j], i = 1:n, j = 1:m)) %>%
  # we cannot exceed the capacity of a course
  add_constraint(sum_expr(x[i, j], i = 1:n) <= capacity[j], j = 1:m) %>% 
  # each student needs to be assigned to one course
  add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>% 
  solve_model(with_ROI(solver = "glpk", verbose = TRUE))


matching <- model %>% 
  get_solution(x[i,j]) %>%
  filter(value > .9) %>%  
  select(i, j) %>% 
  rowwise() %>% 
  mutate(weight = weight(as.numeric(i), as.numeric(j)), 
         preferences = paste0(preferences(as.numeric(i)), collapse = ",")) %>% ungroup

```

##Case 2:

```{r}
##maximize 4x + 3y, subject to the constraints 2x + y ≤ 14, x + 2y ≤ 16, and x, y ≥ 0, where x and y are integers.

###Use lpSolve:
library(lpSolve)

# Define the objective function
f.obj <- c(4, 3)

# Define the matrix of left-hand side coefficients
f.con <- matrix(c(2, 1, 1, 2), nrow=2, byrow=TRUE)

# Define the right-hand side coefficients
f.rhs <- c(14, 16)

# Define the direction of the constraints
f.dir <- c("<=", "<=")

# Solve the problem
solution <- lp("max", f.obj, f.con, f.dir, f.rhs, all.int=TRUE)

# Print the solution
print(solution$solution)

###Use ompr 
library(ompr)
library(dplyr)
library(ompr.roi)
library(ROI.plugin.glpk)

model1<-MIPModel() %>% 
  add_variable(x, type = "integer",lb = 0) %>% 
  add_variable(y, type = "integer",lb = 0) %>%
  set_objective(4*x+3*y,"max") %>% 
  add_constraint(2*x+y <= 14) %>% 
  add_constraint(x+2*y <= 16)%>% 
  solve_model(with_ROI(solver = "glpk", verbose = TRUE))

#Extract for x value:
get_solution(model1,x)
#Extract for y value:
get_solution(model1,y)
#Or:
model1[["solution"]]

```

##Case 3: TSP problem

```{r}
#The number of cities:
n <- 10

#Boundary of our Euclidean space:
##from 0 to ...
max_x <- 500
max_y <- 500

##Plot map of random cities
set.seed(123456)
cities <- data.frame(id = 1:n, x = runif(n, max = max_x), y = runif(n, max = max_y))
ggplot(cities, aes(x, y)) + 
  geom_point()

##Function to calculate the distance:
distance <- as.matrix(stats::dist(select(cities, x, y), diag = TRUE, upper = TRUE))
dist_fun <- function(i, j) {
  vapply(seq_along(i), function(k) distance[i[k], j[k]], numeric(1L))
}
  
model <- MIPModel() %>%
  # create decision variable that is 1 if we travel from node i to j
  add_variable(x[i, j], i = 1:n, j = 1:n, type = "integer", lb = 0, ub = 1) %>%
  # a helper variable for the MTZ formulation of the tsp
  add_variable(u[i], i = 1:n, lb = 1, ub = n) %>% 
  # minimize travel distance
  set_objective(sum_expr(dist_fun(i, j) * x[i, j], i = 1:n, j = 1:n), "min") %>%
  # leave each node
  add_constraint(sum_expr(x[i, j], j = 1:n) == 1, i = 1:n) %>%
  # visit each node
  add_constraint(sum_expr(x[i, j], i = 1:n) == 1, j = 1:n) %>%
  # ensure no subtours (arc constraints)
  add_constraint(u[1] == 1) %>% 
  add_constraint(u[j] >= u[i] + 1 - n * (1 - x[i, j]), i = 1:n, j = 2:n) %>%
  # exclude self-cycles
  set_bounds(x[i, i], ub = 0, i = 1:n)

##solve model with GLPK
result <- solve_model(model, with_ROI(solver = "glpk", verbose = TRUE))

##obtain solution
solution <- get_solution(result, x[i, j]) %>% 
  filter(value > 0) 

##Create table to store the results:
paths <- select(solution, i, j) %>% 
  rename(from = i, to = j) %>% 
  mutate(trip_id = row_number()) %>% 
  tidyr::gather(property, idx_val, from:to) %>% 
  mutate(idx_val = as.integer(idx_val)) %>% 
  inner_join(cities, by = c("idx_val" = "id"))
kable(head(arrange(paths, trip_id), 4))

##Plot the results by map:
ggplot(cities, aes(x, y)) + 
  geom_point() + 
  geom_line(data = paths, aes(group = trip_id)) + 
  ggtitle(paste0("Optimal route with cost: ", round(objective_value(result), 2)))


```

##Case 4: ![maximize profit](/Users/locca/Downloads/4store.png)

```{r}
df<-read.table(text="
Store   Treatment   Cost    Profit
1   A   50  100
1   B   100 200
1   C   75  50
2   A   25  25
2   B   150 0
2   C   50  25
3   A   100 300
3   B   125 250
3   C   75  275
4   A   25  25
4   B   50  75",header=T)

pacman::p_load(dplyr,
               tidyr,
               ROI,
               ROI.plugin.symphony,
               ompr,
               ompr.roi)

# Extract data:
stores<-unique(df$Store)
treatments <- levels(df$Treatment)
num_treatments <- length(treatments)
# cost matrix
cost <- as.matrix(spread(subset(df,select=c(Store,Treatment,Cost)),Treatment,Cost)[,-1])
profit <- as.matrix(spread(subset(df,select=c(Store,Treatment,Profit)),Treatment,Profit)[,-1])
# maximum cost allowed
max_cost <- 300

# MILP model:
m <- MIPModel() %>%
  add_variable(x[i,j], i=stores, j=1:num_treatments, type="binary") %>%
  add_constraint(sum_expr(x[i,j], j=1:num_treatments)<=1, i=stores) %>%
  add_constraint(sum_expr(cost[i,j]*x[i,j], i=stores, j=1:num_treatments) <= max_cost) %>%
  set_objective(sum_expr(profit[i,j]*x[i,j], i=stores, j=1:num_treatments),"max") %>%
  solve_model(with_ROI(solver = "symphony",verbosity=1))

## Get solution:
get_solution(m,x[i, j]) %>%
  filter(value > 0)

```

##Case 5:Warehouse location problem: ![WH location's model](/Users/locca/Downloads/Warehouse_location.png)

```{r}
#Assume the customers are located in a grid with euclidian distances:
set.seed(1234)
grid_size <- 1000
n <- 100
customer_locations <- data.frame(
  id = 1:n,
  x = round(runif(n) * grid_size),
  y = round(runif(n) * grid_size)
)
#Placed randomly 20 WH on the grid:
m <- 20
warehouse_locations <- data.frame(
  id = 1:m,
  x = round(runif(m) * grid_size),
  y = round(runif(m) * grid_size)
)

#Set up the fixed cost:
fixedcost <- round(rnorm(m, mean = grid_size * 10, sd = grid_size * 5))

#Build a functions that takes a customer and a warehouse and returns the transport cost.

transportcost <- function(i, j) {
  customer <- customer_locations[i, ]
  warehouse <- warehouse_locations[j, ]
  round(sqrt((customer$x - warehouse$x)^2 + (customer$y - warehouse$y)^2))
}
transportcost(1, 3)

#Plot the simulation location map of 20 WH:
p <- ggplot(customer_locations, aes(x, y)) + 
  geom_point() + 
  geom_point(data = warehouse_locations, color = "red", alpha = 0.5, shape = 17) +
  scale_x_continuous(limits = c(0, grid_size)) +
  scale_y_continuous(limits = c(0, grid_size)) +
  theme(axis.title = element_blank(), 
        axis.ticks = element_blank(), 
        axis.text = element_blank(), panel.grid = element_blank())
p + ggtitle("Warehouse location problem", 
          "Black dots are customers. Light red triangles show potential warehouse locations.")

#Model: 
library(ompr)
library(magrittr)
model <- MIPModel() %>%
  # 1 iff i gets assigned to warehouse j
  add_variable(x[i, j], i = 1:n, j = 1:m, type = "binary") %>%
  
  # 1 iff warehouse j is built
  add_variable(y[j], j = 1:m, type = "binary") %>%
  
  # maximize the preferences
  set_objective(sum_expr(transportcost(i, j) * x[i, j], i = 1:n, j = 1:m) + 
                  sum_expr(fixedcost[j] * y[j], j = 1:m), "min") %>%
  
  # every customer needs to be assigned to a warehouse
  add_constraint(sum_expr(x[i, j], j = 1:m) == 1, i = 1:n) %>% 
  
  # if a customer is assigned to a warehouse, then this warehouse must be built
  add_constraint(x[i,j] <= y[j], i = 1:n, j = 1:m)
model %>% 
  # Solve model:
  solve_model(with_ROI(solver = "glpk", verbose = TRUE))
              
              
##Extract the result:
suppressPackageStartupMessages(library(dplyr))
matching <- result %>% 
  get_solution(x[i,j]) %>%
  filter(value > .9) %>%  
  select(i, j)

plot_assignment <- matching %>% 
  inner_join(customer_locations, by = c("i" = "id")) %>% 
  inner_join(warehouse_locations, by = c("j" = "id"))
customer_count <- matching %>% group_by(j) %>% summarise(n = n()) %>% rename(id = j)
plot_warehouses <- warehouse_locations %>% 
  mutate(costs = fixedcost) %>% 
  inner_join(customer_count, by = "id") %>% 
  filter(id %in% unique(matching$j))
p + 
  geom_segment(data = plot_assignment, aes(x = x.y, y = y.y, xend = x.x, yend = y.x)) + 
  geom_point(data  = plot_warehouses, color = "red", size = 3, shape = 17) +
  ggrepel::geom_label_repel(data  = plot_warehouses, 
                            aes(label = paste0("fixed costs:", costs, "; customers: ", n)), 
                            size = 2, nudge_y = 20) + 
  ggtitle(paste0("Cost optimal warehouse locations and customer assignment"),
          "Big red triangles show warehouses that will be built, light red are unused warehouse locations. 
Dots represent customers served by the respective warehouses.")
```

##Case 6: Knapsack problem ![WH location's model](/Users/locca/Downloads/Knapsack%20problem.png)

```{r}
n <- 10; W <- 2
v <- runif(n);w <- runif(n)
model3 <- MIPModel() %>% 
  add_variable(x[i], i = 1:n, type = "binary") %>% 
  set_objective(sum_expr(v[i] * x[i], i = 1:n)) %>% 
  add_constraint(sum_expr(w[i] * x[i], i = 1:n) <= W) %>% 
  # Solve model:
  solve_model(with_ROI(solver = "glpk", verbose = TRUE))

```

##Case 7: GA

```{r}
theta = seq(from = 0, to= 1, by=0.01)
#Add beta distribution for theta:
alpha = 1; beta = 1
prior = rbeta(theta,alpha,beta)
#Real data:
nA = 120; xA = 20 
likelihood_A = theta^xA*(1-theta)^(nA-xA)

nB = 120; xB = 20 
likelihood_B = theta^xB*(1-theta)^(nB-xB)

popular2data <- read_sav(file = "https://github.com/MultiLevelAnalysis/Datasets-third-edition-Multilevel-book/blob/master/chapter%202/popularity/SPSS/popular2.sav?raw=true")
popular2data <- select(popular2data, pupil, class, extrav, sex, texp, popular) # we select just the variables we will use


library(GA)
data("eurodist", package = "datasets")
D <- as.matrix(eurodist)

#Function to calculate tour length 

tourLength <- function(tour, distMatrix) {
  tour <- c(tour, tour[1])
  route <- embed(tour, 2)[,2:1]
  sum(distMatrix[route])
}

#Firness function to be maximized

tspFitness <- function(tour, ...) 1/tourLength(tour, ...)

GA <- ga(type = "permutation", 
         fitness = tspFitness, 
         distMatrix = D,
         min = 1, 
         max = attr(eurodist, "Size"), 
         popSize = 50, 
         maxiter = 5000,
         run = 500, 
         pmutation = 0.2)

```

##Case 8: Transshipment problem: ![Transshipment's model](/Users/locca/Downloads/CrossDocking.png)

```{r}
#Input:
Supply <-c(200,300,100,150,220)
Demand <-c(150,100,110,200,180)
DC<-2
m<-length(Supply)
n<-length(Demand)

Cost_CD<-read.table(text = 
                    "CD1 CD2
                     30 50
                     23 66
                     35 14
                     70 12
                     65 70",header = T)
Cost_DC<-read.table(text = 
                      "DC1 DC2 DC3 DC4 DC5
                       12 25 22 40 41
                       65 22 23 12 15",header = T)

#MILP model from the 
model5 <- MIPModel() %>%
  # Add variable
  add_variable(x[i, j], i = 1:m, j = 1:DC) %>%
  add_variable(y[j, k], j = 1:DC, k = 1:n) %>%
  # minimize the cost of transshipment:
  set_objective(sum_expr(x[i, j]*Cost_CD[i, j],i = 1:m, j = 1:DC)+ sum_expr(y[j, k]*Cost_DC[j, k], k = 1:n, j = 1:DC),"min") %>%
  add_constraint(sum_expr(y[j, k], j = 1:DC) >= Demand[k], k = 1:n) %>%
  # The amount of inventory in Crossdocking is smaller than production goods
  add_constraint(sum_expr(x[i, j], j = 1:DC) <= Supply[i], i = 1:m) %>% 
  # The amount of is bigger than demand in DC
  add_constraint(sum_expr(x[i, j], i = 1:m) - sum_expr(y[j, k], k = 1:n) >= 0,j = 1:DC) %>%
  add_constraint(x[i, j] >= 0, j = 1:DC, i = 1:m)%>% 
  add_constraint(y[j, k] >= 0, j = 1:DC, k = 1:n)%>% 
  #Solve the model:
  solve_model(with_ROI(solver = "glpk", verbose = TRUE))

(solution <- get_solution(model5, x[i, j]) %>% 
     filter(value > 0))
```
